Домашно 11
===========

##Задачи##
Решенията на задачите се предават по e-mail на адрес:

> ivan.vladimirov.ivanov@gmail.com

Решението на всяка задача трябва да бъде под формата на файл с окончание *.hs*, който да съдържа дефиницията на функцията (със точната сигнатура дефинирана в условието на задачата) и евентуално други помощни дефиниции, необходими за реализацията. Файловете се изпращат като attachment-и в mail-a. Освен решения на задачите самият mail трябва да съдържа име и факултен номер. Успех!

За инструкции как да експериментирате с функции на Haskell дефинирани в отделен файл вижте [тук](https://github.com/IvanIvanov/fp2013/wiki/%D0%98%D0%BD%D1%81%D1%82%D0%B0%D0%BB%D0%B0%D1%86%D0%B8%D1%8F-%D0%B8-%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B0-%D1%81-Haskell-Platform#%D0%9A%D0%B0%D0%BA-%D0%B4%D0%B0-%D1%81%D1%82%D0%B0%D1%80%D1%82%D0%B8%D1%80%D0%B0%D0%BC%D0%B5-%D0%B8%D0%BD%D1%82%D0%B5%D1%80%D0%B0%D0%BA%D1%82%D0%B8%D0%B2%D0%BD%D0%B0-%D1%81%D1%80%D0%B5%D0%B4%D0%B0-%D0%B7%D0%B0-%D0%B5%D0%BA%D1%81%D0%BF%D0%B5%D1%80%D0%B8%D0%BC%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%B0%D0%BD%D0%B5-%D1%81-haskell-repl).

### Задача 1 ###
Нека е дефиниран следният `type synonym`:
```Haskell
type Product = (String, Double)
```

Типът `Product` описва стока в магазин, като я моделира като наредена двойка ([tuple](http://learnyouahaskell.com/starting-out#tuples)), където първият елемент е името на стоката, а вторият е цената. 

Да се дефинирана функция `expensiveProducts`, която получава списък от стоки и връща списък от имената на всички стоки стрикно по-скъпи от средно аритметичната цена на входните стоки. Редът на имената на върнатите стоки трябва да съвпада с реда на съответните стоки във входния списък.

**Сигнатура:**
```Haskell
expensiveProducts :: [Product] -> [String]
```

**Примери:**
```Haskell
expensiveProducts [("foo", 1), ("bar", 1), ("baz", 1)] -> []
expensiveProducts [("a", 1), ("b", 2), ("c", 3), ("d", 4), ("e", 5)] -> ["d","e"]
expensiveProducts [("crappy food", 1.20), ("suhsi", 12.0), ("car", 20000.0), ("house", 200000.0)] -> ["house"] 
```

*Hint:* За повече информация относно `type synonyms` вижте [тук](http://learnyouahaskell.com/making-our-own-types-and-typeclasses#type-synonyms). При изчисляването на средното аритметично може да ви се наложи да използвате оператора `/`. Трябва да имате предвид, че той работи само ако двата аргумента са реални числа (например `Double`). Това означава, че ако единият аргумент е цяло число трябва да го превърнете в `Double`, като използвате вградената функция `fromIntegral`. Например:

```Haskell
42.0 / (fromIntegral 10)
```

### Задача 2 ###
Нека е дефиниран следният алгебраичен тип данни за бинарно дърво:

```Haskell
data Tree a = Empty
            | Node a (Tree a) (Tree a)
```

Да се дефинира функция `treeLevel`, която получава като вход двоично дърво и неотрицателно цяло число `level` и връща като резултат списък от всички стойности на дървото, които сa на даденото ниво (`level`). Стойностите на елементите на дадено ниво трябва да бъдат подредени от ляво на дясно в резултатния списък. Нивото на един връх е дефинирано по следния начин. Нивото на корена на дървото е 0. Нивото на всеки друг възел на дървото е 1 + нивото на неговия родител.

**Сигнатура:**
```Haskell
treeLevel :: Tree a -> Int -> [a]
```

**Примери:**
```Haskell
-- Входното дърво изглежда така:
--
--        10              level 0
--       /  \
--      5   20            level 1
--     /    / \
--    4   15  25          level 2
--
treeLevel (Node 10 (Node 5 (Node 4 Empty Empty) Empty) (Node 20 (Node 15 Empty Empty) (Node 25 Empty Empty))) 0 -> [10]
treeLevel (Node 10 (Node 5 (Node 4 Empty Empty) Empty) (Node 20 (Node 15 Empty Empty) (Node 25 Empty Empty))) 1 -> [5,20]
treeLevel (Node 10 (Node 5 (Node 4 Empty Empty) Empty) (Node 20 (Node 15 Empty Empty) (Node 25 Empty Empty))) 2 -> [4,15,25]
treeLevel (Node 10 (Node 5 (Node 4 Empty Empty) Empty) (Node 20 (Node 15 Empty Empty) (Node 25 Empty Empty))) 3 -> []
```

Hint: За конкатениране на елементите от два списъка може да се използва оператора `++`. Например:
```Haskell
[1, 2, 3] ++ [4, 5, 6] -> [1, 2, 3, 4, 5, 6]
```

### Задача 3 ###
Да се дефинира функция `treeLevels`, която получава като аргумент двоично дърво и връща като резултат списък от всички нива на дърво. Първият елемент от резултатния списък е нулевото ниво на дървото, вторият елемент е първото ниво на дървото и т.н. Всяко ниво представлява списък от елементите на това ниво, взети от ляво на дясно. За повече информация вижте `Задача 2`.

**Сигнатура:**
```Haskell
treeLevels :: Tree a -> [[a]]
```

**Примери:**
```Haskell
treeLevels Empty -> []
treeLevels (Node 1 (Node 2 Empty Empty) (Node 3 Empty Empty)) -> [[1],[2,3]]

-- За визуална представа на входното дърво вижте прирма на Задача 2`.
treeLevels (Node 10 (Node 5 (Node 4 Empty Empty) Empty) (Node 20 (Node 15 Empty Empty) (Node 25 Empty Empty))) -> [[10],[5,20],[4,15,25]]
```

*Hint:* Може да използвате решението от предишната задача, комбинирано с `map` и функция, която да изчислява броя на нивата на дадено двоично дърво.


##Препоръчани материали:##

* От [Learn You a Haskell for Great Good](http://learnyouahaskell.com/chapters) - [Making Our Own Types and Typeclasses](http://learnyouahaskell.com/making-our-own-types-and-typeclasses).

