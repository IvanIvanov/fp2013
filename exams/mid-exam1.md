# Контролни и Изпити

## Контролно 1 - 23.11

Задачите от първото контролно по Функционално Програмиране

### Вариант 1

#### Задача 1
Едно число се нарича "четновато" (evenly), ако броят на делителите му е четно число. Да се напише функция sum-of-evenly, която да намери сумата от всички "четновати" числа в интервала [a, b], където a и b са цели числа и 1 <= a <= b <= 1000. Първите три "четновати" числа са 2 (делителите са 1 и 2 или общо 2 на брой), 3 (делителите са 1 и 3 или общо 2 на брой) и 5 (делителите са 1 и 5 или общо 2 на брой).

__Сигнатура:__
```scheme
(define (sum-of-evenly a b) ... )
```

__Примери:__
```scheme
(sum-of-evenly 1 10)      ->  41   (2 + 3 + 5 + 6 + 7 + 8 + 10)
(sum-of-evenly 100 200) ->  14420
(sum-of-evenly 1 42)      ->   812
```

#### Задача 2
Нека L е “сгънат” списък в следния формат:
```L = ( (E1 C1) (E2 C2) ... (EN CN))```, където Ei е елемент (S-израз), а Ci е броят на срещанията му.
Да се напише функция (unpack L), която “разгъва” L в списък, в който всеки от елементите Ei се среща последователно Ci пъти.

__Сигнатура:__
```scheme
(define (unpack L) ... )
```

__Примери:__
```scheme
(unpack '((1 2) (5 3) (10 3)))  ->  (1 1 5 5 5 10 10 10)
(unpack '((1 2) (5 3) (10 0)))  ->  (1 1 5 5 5)
(unpack '((9 1) (0 10)))         ->  (9 0 0 0 0 0 0 0 0 0 0)
```

#### Задача 3
Да се дефинира функция sublist, която получава като аргументи два списъка list1 и list2 и връща #t, ако list1 e непрекъснат подсписък на list2, или #f в противен случай. Може да се предположи, че списъците ще бъдат съставени изцяло от числа.

__Сигнатура:__
```scheme
(define (sublist list1 list2) ... )
```
__Примери:__
```scheme
(sublist '(1 2 3) '(1 2 3 4 5))  ->  #t
(sublist '(3 4 5) '(1 2 3 4 5))  ->  #t
(sublist '(2 3 4) '(1 2 3 4 5))  ->  #t
(sublist '(1 2 4) '(1 2 3 4 5))  ->  #f
```

#### Задача 4

Частичното прилагане на функция е техника, при която можем да извикаме една n-аргументна функция, като й подадем само k (k < n) аргумента - т.е можем да извикаме функцията само с част от аргументите, които тя очаква. Резултатът от частичното прилагане на функция е нова функция, която изисква само n - k аргумента, тъй като стойностите на останалите k са били определени при частичното прилагане. В тази задача се очаква да се напише функция от по-висок ред, която да реализира частен случай на частичното прилагане, в който се прилагат частично само двуаргументни функции, като се задава стойността на първия аргумент. 
Да се дефинира функция partial-apply2, която приема двуаргументна функция и стойност за първия й аргумент и връща като резултат функция, приемаща един аргумент, която е резултатът от частичното прилагане на входната функция върху дадения първи аргумент.

__Сигнатура:__
```scheme
(define (partial-apply2 f a1) ... )
```
__Примери:__
```scheme
((partial-apply2 + 0) 10)   ->  10
((partial-apply2 + 1) 10)   ->  11
((partial-apply2 min 5) 3)  ->  3
((partial-apply2 min 5) 8)  ->  5
```

#### Задача 5

Матрица може да се моделира като списък от списъци, като вложените списъци представляват редовете на матрицата.
Да се дефинира функция delete-col, която приема като аргумент матрица matrix и индекс i на стълб и връща като резултат нова матрица, в която i-тия стълб е премахнат. Може да се предположи, че индексът i ще е между 1 и броя на стълбовете на входната матрица.
Индексите на стълбовете започват от 1 (а не от 0).

__Сигнатура:__
```scheme
(define (delete-col matrix i) ... )
```
__Примери:__
```scheme
(delete-col '((1 2 3) (4 5 6)) 1)     ->  ((2 3) (5 6))
(delete-col '((1 2) (3 4) (5 6)) 2)   ->  ((1) (3) (5))
```

### Вариант 2

#### Задача 1
Едно число се нарича "нечетновато" (oddly), ако броят на делителите му е нечетно число. Да се напише функция sum-of-oddly, която да намери сумата от всички "нечетновати" числа в интервала [a, b], където a и b са цели числа и 1 <= a <= b <= 1000. Първите три "нечетновати" числа са 1 (делителите са 1 или общо 1 на брой), 4 (делителите са 1, 2 и 4 или общо 3 на брой) и 9 (делителите са 1, 3 и 9 или общо 3 на брой).

__Сигнатура:__
```scheme
(define (sum-of-oddly a b) ... )
```
__Примери:__
```scheme
(sum-of-oddly 1 10)  ->   14   (1 + 4 + 9)
(sum-of-oddly 100 200)  ->   730
(sum-of-oddly 1 42)  ->   91
```

#### Задача 2
Да се дефинира функция occur-k, която получава като аргументи списък items и цяло число k и връща като резултат нов списък, състоящ се само от тези елементи на входния списък, които се срещат точно k на брой пъти в items. Редът на елементите във върнатия списък трябва да съвпада с реда на съответния елемент в списъка items. Може да се предположи, че елементите на списъка items са числа и 1 <= k <= 1000.

__Сигнатура:__
```scheme
(define (occur-k items k) ... )
```
__Примери:__
```scheme
(occur-k '(1 2 3 5 2 5) 1)  ->  (1 3)
(occur-k '(1 2 3 5 2 5) 2)  ->  (2 5 2 5)
(occur-k '(1 2 3 5 2 5) 3)  ->  ()
```
#### Задача 3
Да се дефинира функция deepest-atom, която получава списък от списъци с произволно ниво на вложение и връща като резултат дълбочината на най-дълбоко разположения атом. Дълбочината на един атом се определя от броя на списъците, в който той е вложен пряко или непряко. Може да се предположи, че никой от вложените списъци няма да е празен.

__Сигнатура:__
```scheme
(define (deepest-atom tree) ... )
```
__Примери:__
```scheme
(deepest-atom '(1 2 3))           ->  1
(deepest-atom '(1 (2 (3 4)) 5))  ->  3
(deepest-atom '(1 (2 3 (4 5))))  ->  3
```
#### Задача 4
Да се напише функция both-in, която има следната сигнатура:
```(define (both-in f g start end))``` ,
където ```f``` и ```g``` са едноаргументни целочислени функции, а ```start``` и ```end``` са двата края на целочислен интервал. 
Функцията both-in да връща като резултат друга функция - едноместен предикат, чиято върната стойност е true (#t) за всички стойности на аргумента x, за които стойностите ```(f x)``` и ```(g x)``` са в интервала ```[start, end]```.

__Сигнатура:__
```scheme
(define (both-in f g start end) ... )
```
__Примери:__
```scheme
(both-in (lambda (x) (* x 2)) (lambda (x) (* x 3)) -10 10)         ->  #<procedure:........>
( (both-in (lambda (x) (* x 2)) (lambda (x) (* x 3)) -10 10) 1)   ->  #t
( (both-in (lambda (x) (* x 2)) (lambda (x) (* x 3)) -10 10) 2)   ->  #t
( (both-in (lambda (x) (* x 2)) (lambda (x) (* x 3)) -10 10) 3)   ->  #t
( (both-in (lambda (x) (* x 2)) (lambda (x) (* x 3)) -10 10) 4)   ->  #f
```
#### Задача 5

Матрица може да се моделира като списък от списъци, като вложените списъци представляват редовете на матрицата.
Да се дефинира функция delete-row, която приема като аргумент матрица matrix и индекс i на ред и връща като резултат нова матрица, в която i-тия ред е премахнат. Може да се предположи, че индексът i ще е между 1 и броя на редовете на входната матрица.
Индексите на редовете започват от 1 (а не от 0).

__Сигнатура:__
```scheme
(define (delete-row matrix i) ... )
```
__Примери:__
```scheme
(delete-row '((1 2 3) (4 5 6)) 1)    ->  ((4 5 6))
(delete-row '((1 2) (3 4) (5 6)) 2)  ->  ((1 2) (5 6))
```