# Контролни и Изпити

## Контролно 1 - 23.11

Задачите от първото контролно по Функционално Програмиране

### Вариант 1

#### Задача 1
Едно число се нарича "четновато" (evenly), ако броят на делителите му е четно число. Да се напише функция sum-of-evenly, която да намери сумата от всички "четновати" числа в интервала [a, b], където a и b са цели числа и 1 <= a <= b <= 1000. Първите три "четновати" числа са 2 (делителите са 1 и 2 или общо 2 на брой), 3 (делителите са 1 и 3 или общо 2 на брой) и 5 (делителите са 1 и 5 или общо 2 на брой).

__Сигнатура:__
```scheme
(define (sum-of-evenly a b) … )
```

__Примери:__
```scheme
(sum-of-evenly 1 10)      →  41   (2 + 3 + 5 + 6 + 7 + 8 + 10)
(sum-of-evenly 100 200) →  14420
(sum-of-evenly 1 42)      →   812
```

#### Задача 2
Нека L е “сгънат” списък в следния формат:
```L = ( (E1 C1) (E2 C2) ... (EN CN))```, където Ei е елемент (S-израз), а Ci е броят на срещанията му.
Да се напише функция (unpack L), която “разгъва” L в списък, в който всеки от елементите Ei се среща последователно Ci пъти.

__Сигнатура:__
```scheme
(define (unpack L) … )
```

__Примери:__
```scheme
(unpack '((1 2) (5 3) (10 3)))  →  (1 1 5 5 5 10 10 10)
(unpack '((1 2) (5 3) (10 0)))  →  (1 1 5 5 5)
(unpack '((9 1) (0 10)))         →  (9 0 0 0 0 0 0 0 0 0 0)
```

#### Задача 3
Да се дефинира функция sublist, която получава като аргументи два списъка list1 и list2 и връща #t, ако list1 e непрекъснат подсписък на list2, или #f в противен случай. Може да се предположи, че списъците ще бъдат съставени изцяло от числа.
__Сигнатура:__
```scheme
(define (sublist list1 list2) … )
```
__Примери:__
```scheme
(sublist '(1 2 3) '(1 2 3 4 5))  →  #t
(sublist '(3 4 5) '(1 2 3 4 5))  →  #t
(sublist '(2 3 4) '(1 2 3 4 5))  →  #t
(sublist '(1 2 4) '(1 2 3 4 5))  →  #f
```

#### Задача 4

Частичното прилагане на функция е техника, при която можем да извикаме една n-аргументна функция, като й подадем само k (k < n) аргумента - т.е можем да извикаме функцията само с част от аргументите, които тя очаква. Резултатът от частичното прилагане на функция е нова функция, която изисква само n - k аргумента, тъй като стойностите на останалите k са били определени при частичното прилагане. В тази задача се очаква да се напише функция от по-висок ред, която да реализира частен случай на частичното прилагане, в който се прилагат частично само двуаргументни функции, като се задава стойността на първия аргумент. 
Да се дефинира функция partial-apply2, която приема двуаргументна функция и стойност за първия й аргумент и връща като резултат функция, приемаща един аргумент, която е резултатът от частичното прилагане на входната функция върху дадения първи аргумент.

__Сигнатура:__
```scheme
(define (partial-apply2 f a1) … )
```
__Примери:__
```scheme
((partial-apply2 + 0) 10)   →  10
((partial-apply2 + 1) 10)   →  11
((partial-apply2 min 5) 3)  →  3
((partial-apply2 min 5) 8)  →  5
```

#### Задача 5

Матрица може да се моделира като списък от списъци, като вложените списъци представляват редовете на матрицата.
Да се дефинира функция delete-col, която приема като аргумент матрица matrix и индекс i на стълб и връща като резултат нова матрица, в която i-тия стълб е премахнат. Може да се предположи, че индексът i ще е между 1 и броя на стълбовете на входната матрица.
Индексите на стълбовете започват от 1 (а не от 0).

__Сигнатура:__
```scheme
(define (delete-col matrix i) … )
```
__Примери:__
```scheme
(delete-col '((1 2 3) (4 5 6)) 1)     →  ((2 3) (5 6))
(delete-col '((1 2) (3 4) (5 6)) 2)   →  ((1) (3) (5))
```

### Вариант 2