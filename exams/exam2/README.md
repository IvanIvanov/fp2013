## Контролно 2 - 11.01 ##

### Вариант 1 ###

#### Задача 1 ####

Един списък *А* е подпоследователност на друг списък *B*, ако след премахването на произволен брой елементи от *B* се получава *А* (възможно е да се премахнат и 0 елементи от *B*).

Да се дефинира функция `subsequence`, която получава два списъка и връща `True`, ако първият списък е подпоследователност на втория, или `False` в противен случай.

**Сигнатура**:
```Haskell
subsequence :: (Eq a) => [a] -> [a] -> Bool
```

**Примери:**
```Haskell
subsequence [] [] -> True
subsequence [] [1,2,3] -> True
subsequence [1,2,3] [] -> False
subsequence [42] [1,2,3] -> False
subsequence [5,10,20] [2,5,6,7,10,12,20,30] -> True
subsequence [3,4,42] [1,2,3,4,44] -> False
subsequence [1,2,3] [3,2,1] -> False
```

#### Задача 2 ####
Казваме, че една функция *f* е строго монотонно растяща в челочислен интервал *[a, b]*, ако за всеки две целочислени стойности *x* и *y (x < y)* в *[a, b]* е изпълнено *f(x) < f(y)*.

Да се дефинира функция `increasing`, която получава като аргументи функция *f* и числата *a* и *b* и връща `True`, ако функцията *f* e строго монотонно растяща в интервала *[a, b]*, или `False` в противен случай. Може да се предположи, че *а <= b*.

**Сигнатура:**
```Haskell
increasing :: (Int -> Int) -> Int -> Int -> Bool
```

**Примери:**
```Haskell
increasing (\x -> x + 1) 1 100 -> True
increasing (\x -> 1 - x) 1 100 -> False
increasing (\x -> 1 - x) 100 100 -> True
increasing (\x -> 42) 1 100 -> False
increasing (\x -> 42) 1 1 -> True
```

#### Задача 3 ####
Да се дефинира функция `divisorsOfEvenNumbers`, която получава един аргумент *n* и връща безкраен списък от делителите на всички четни цели числа, по-големи или равни на *n*. Делителите на едно число *k* се представят като списък от числа. Например делителите на 10 се представят чрез списъка [1, 2, 5, 10].

**Сигнатура:**
```Haskell
divisorsOfEvenNumbers :: Integer -> [[Integer]]
```

**Примери:**
```Haskell
take 5 (divisorsOfEvenNumbers 1)
 -> [[1,2],[1,2,4],[1,2,3,6],[1,2,4,8],[1,2,5,10]]

take 3 (divisorsOfEvenNumbers 10)
 -> [[1,2,5,10],[1,2,3,4,6,12],[1,2,7,14]]
```

#### Задача 4 ####
В една вселена, паралелна на нашата, книгите ядат книжни червеи. И тъй като книгите трябва да се поддържат във форма (колкото по-дебела е една книга, толкова по-добре), те са си измислили формула, по която изчисляват колко хранителен е един червей.

```
Хранителност ( Червей ) = (Дължина на червея * брой символи в името на червея) / (брой съгласни букви в името на червея)
```

Функцията връща цяло число, получено в резултат на целочислено деление. Може да се предположи, че всички имена съдържат поне една съгласна буква.

В паралелната вселена всички червени са с имена, изписани само с малки букви.

Съгласните са елементи на `bcdfghjklmnqrstvwxz`.

Ще моделираме червей така:

```Haskell
type Worm = (String, Int) -- името и дължината на червея
```

Напишете функция `wormsToEat`, която приема списък с червеи и цяло число, представляващо долната граница на хранителност, допустима за дадена книга.

Функцията да връща списък с имената на тези червеи, които ще са достатъчно хранителни (хранителността им е >= от долната граница на хранителност) за същата книга.

**Сигнатура:**
```Haskell
wormsToEat :: [Worm] -> Int -> [String]
```

**Примери:**
```Haskell
worms = [ ("erdfhgjdr", 44), ("rrrrghrharg", 100),
          ("why i have so many vowels", 66), ("grrragrgh!", 32),
          ("pinky", 14), ("beefcake", 100) ]

wormsToEat worms 50 -> ["rrrrghrharg","why i have so many vowels","beefcake"]
wormsToEat worms 150 -> ["why i have so many vowels","beefcake"]
wormsToEat worms 200 -> ["beefcake"]
```

#### Задача 5 ####
Казваме, че едно двоично дърво е конус, ако сумата на елементите на всяко ниво в дървото е по-голяма от сумата на елементите на предишното ниво.

a) Да се дефинира функция `levelSum t k`, която намира сумата на елементите на ниво *k* в дървото *t*.

b) Да се дефинира функция `cone t`, която проверява дали дървото *t* е конус.

Приемаме, че коренът на дървото е на ниво 0. Да се използва следната дефиниция на двоично дърво:
```Haskell
data BTree = Empty | BTree Int BTree BTree
```

**Сигнатура:**
```Haskell
levelSum :: BTree -> Int -> Int
cone :: BTree -> Bool
```

**Примери:**
```Haskell
levelSum Empty 0 -> 0
levelSum (BTree 1 (BTree 2 Empty Empty) (BTree 3 Empty Empty)) 0 -> 1
levelSum (BTree 1 (BTree 2 Empty Empty) (BTree 3 Empty Empty)) 1 -> 5
levelSum (BTree 1 (BTree 2 Empty Empty) (BTree 3 Empty Empty)) 2 -> 0

cone Empty -> True
cone (BTree 1 (BTree 2 Empty Empty) (BTree 3 Empty Empty)) -> True
cone (BTree 5 (BTree 2 Empty Empty) (BTree 3 Empty Empty)) -> False
cone (BTree 1 (BTree 2 Empty Empty) (BTree 3 Empty (BTree 4 Empty Empty))) -> False
```

### Вариант 2 ###

#### Задача 1 ####
Съдържанието на един списък от числа може да се пакетира, като всяка последователност от еднакви числа се замени с наредена двойка от числото и броя на срещанията му. Например пакетираният вид на списъка: `[5,5,1,7,7,7]` е `[(5,2),(1,1),(7,3)]`.

Да се дефинира фунцкция `pack`, която приема списък от цели числа и връща пакетирания вариант на списъка.

**Сигнатура:**
```Haskell
pack :: [Int] -> [(Int,Int)]
```

**Примери:**
```Haskell
pack [] -> []
pack [5,5,1,7,7,7] -> [(5,2),(1,1),(7,3)]
pack [1,1,1,1,1,1,1,1,1,1] -> [(1,10)]
```

#### Задача 2 ####
Казваме, че една функция *f* е строго монотонно намаляваща в челочислен интервал *[a, b]*, ако за всеки две целочислени стойности *x* и *y (x < y)* в *[a, b]* е изпълнено *f(x) > f(y)*.

Да се дефинира функция `decreasing`, която получава като аргументи функция *f* и числата *a* и *b* и връща `True`, ако функцията *f* e строго монотонно намаляваща в интервала *[a, b]*, или `False` в противен случай. Може да се предположи, че *а <= b*.

**Сигнатура:**
```Haskell
decreasing :: (Int -> Int) -> Int -> Int -> Bool
```

**Примери:**
```Haskell
decreasing (\x -> 1 - x) 1 100 -> True
decreasing (\x -> x + 1) 1 100 -> False
decreasing (\x -> x + 1) 100 100 -> True
decreasing (\x -> 42) 1 100 -> False
decreasing (\x -> 42) 1 1 -> True
```

#### Задача 3 ####
Да се дефинира функция `divisorsOfOddNumbers`, която получава един аргумент *n* и връща безкраен списък от делителите на всички нечетни цели числа, по-големи или равни на *n*. Делителите на едно число *k* се представят като списък от числа. Например делителите на 9 се представят чрез списъка [1, 3, 9].

**Сигнатура:**
```Haskell
divisorsOfOddNumbers :: Integer -> [[Integer]]
```

**Примери:**
```Haskell
take 5 (divisorsOfOddNumbers 1)  -> [[1],[1,3],[1,5],[1,7],[1,3,9]]
take 3 (divisorsOfOddNumbers 10) -> [[1,11],[1,13],[1,3,5,15]]
```

#### Задача 4 ####
Книжните червеи ядат книги. И тъй като има много книги, книжните червеи са измислили функция, с която да ги оценяват по вкус.

```
Вкуснота ( Книга ) = (брой страници * брой гласни букви в името на  книгата ) / дължината на името на книгата
```

Функцията връща цяло число, получено в резултат на целочислено деление. Може да се предположи, че всички имена съдържат поне една съгласна буква.

Брой гласни букви в името = броя на всички малки гласни букви + броя на всички главни гласни букви.

Така в "To Kill A Mockingbird" има 6 гласни букви. Всички гласни са елементи на `aeiouyAEIOUY`.

Ще моделираме книга така:

```Haskell
type Book = (String, Int) -- (име, брой страници)
```

Напишете функция `booksToEat`, която приема списък с книги и цяло число, представляващо долната граница на вкуснота за даден червей.

Функцията да връща списък с имената на тези книги, които ще са достатъчно вкусни за ядене (вкуснотата им е >= на долната граница) за същия червей.

**Сигнатура:**
```Haskell
booksToEat :: [Book] -> Int -> [String]
```

**Примери:**
```Haskell
books = [ ("To Kill A Mockingbird", 324), ("1984", 328),
          ("The Catcher in the Rye", 277), ("The Great Gatsby", 180),
          ("Harry Potter and the Sorcerer's Stone", 310),
          ("The Little Prince", 84), ("Animal Farm", 112),
          ("The Hobbit", 365) ]

booksToEat books 30 -> ["To Kill A Mockingbird","The Catcher in the Rye","The Great Gatsby","Harry Potter and the Sorcerer's Stone","Animal Farm","The Hobbit"]
booksToEat books 90 -> ["To Kill A Mockingbird","Harry Potter and the Sorcerer's Stone","The Hobbit"]
booksToEat books 100 -> ["The Hobbit"]
booksToEat books 200 -> []
```

#### Задача 5 ####
Казваме, че едно двоично дърво е ветрило, ако максималният елемент на всяко ниво в дървото е по-голям от максималния елемент на предишното ниво.

a) Да се дефинира функция `levelMax t k`, която намира максималния елемент на ниво *k* в дървото *t*.

b) Да се дефинира функция `fan t`, която проверява дали дървото *t* е ветрило.

Приемаме, че коренът на дървото е на ниво 0. Да се използва следната дефиниция на двоично дърво:

```Haskell
data BTree = Empty | BTree Int BTree BTree
```

**Сигнатура:**
```Haskell
levelMax :: BTree -> Int -> Int
fan :: BTree -> Bool
```

**Примери:**
```Haskell
levelMax Empty 0 -> 0
levelMax (BTree 1 (BTree 2 Empty Empty) (BTree 3 Empty Empty)) 0 -> 1
levelMax (BTree 1 (BTree 2 Empty Empty) (BTree 3 Empty Empty)) 1 -> 3
levelMax (BTree 1 (BTree 2 Empty Empty) (BTree 3 Empty Empty)) 2 -> 0

fan Empty -> True
fan (BTree 1 (BTree 2 Empty Empty) (BTree 3 Empty Empty)) -> True
fan (BTree 5 (BTree 2 Empty Empty) (BTree 3 Empty Empty)) -> False
fan (BTree 1 (BTree 2 Empty Empty) (BTree 3 Empty (BTree 3 Empty Empty))) -> False
```

